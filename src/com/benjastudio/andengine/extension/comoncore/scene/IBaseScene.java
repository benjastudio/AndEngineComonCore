package com.benjastudio.andengine.extension.comoncore.scene;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Queue;
import java.util.Set;
import java.util.concurrent.ArrayBlockingQueue;

import org.andengine.entity.scene.ITouchArea;
import org.andengine.entity.scene.Scene;
import org.andengine.entity.util.FPSLogger;
import org.andengine.extension.debugdraw.DebugRenderer;
import org.andengine.extension.physics.box2d.PhysicsWorld;
import org.andengine.opengl.texture.atlas.bitmap.BitmapTextureAtlas;

import com.benjastudio.andengine.extension.comoncore.BaseScript;
import com.benjastudio.andengine.extension.comoncore.EngineBundle;
import com.benjastudio.andengine.extension.comoncore.IManagerBundle;
import com.benjastudio.andengine.extension.comoncore.SettingsManager;
import com.benjastudio.andengine.extension.comoncore.Scriptable;
import com.benjastudio.andengine.extension.comoncore.entity.effect.RectangleEffect;
import com.benjastudio.andengine.extension.comoncore.entity.ui.button.DebugGrid;
import com.benjastudio.andengine.extension.comoncore.entity.ui.button.MuteButton;

import android.util.Log;

public abstract class IBaseScene<T extends IManagerBundle, TSceneType extends Enum<TSceneType>>
		extends Scene implements SceneObservable, Scriptable {

	static private final String TAG = "IBaseScene";

	public EngineBundle eBundle;
	public T mBundle;

	private boolean prepared;
	private boolean disposed;
	public List<ITouchArea> iTouchAreaList;
	public Set<BitmapTextureAtlas> autoGeneratedBitmapTextureAtlasSet; // textures
																		// to
																		// unload
																		// when
																		// dispose()
																		// is
																		// called

	public float[] boundsTBLR1;

	public PhysicsWorld physicsWorld;

	public int MAX_SIZE_SUBSCENE_QUEUE = 8;

	private ArrayList<SceneObserver> sceneObservers;

	private Queue<ISubScene<T, TSceneType>> subSceneQueue;

	// Constructors
	public IBaseScene(EngineBundle pEBundle, T pMBundle) {
		eBundle = pEBundle;
		mBundle = pMBundle;

		prepared = false;
		disposed = true;
		boundsTBLR1 = new float[] { -getSceneWidth() * 0.5f,
				getSceneHeight() + getSceneWidth() * 0.5f,
				-getSceneWidth() * 0.5f, getSceneWidth() * 1.5f };

		subSceneQueue = new ArrayBlockingQueue<ISubScene<T, TSceneType>>(
				MAX_SIZE_SUBSCENE_QUEUE);

		setTouchAreaBindingOnActionDownEnabled(true);
	}

	// Abstraction
	public abstract TSceneType getSceneType();

	public abstract void onResume();

	public abstract void onStop();

	public abstract void onPause();

	public abstract void onBackKeyPressed();

	public abstract void onMenuKeyPressed();

	public abstract String getMusic();

	public abstract int getLayerCount();

	public abstract int getDebugLayerId();

	public abstract int getTouchLayerId();

	public abstract boolean isBox2dDebugForced();

	public void setProgress(int pProgress) {
	}

	public void onPauseGame() {
	}

	private void log(String text) {
		Log.d(TAG, getSceneType() + ": " + text);
	}

	@Override
	public void addSceneObserver(SceneObserver object) {
		sceneObservers.add(object);
	}

	@Override
	public void removeSceneObserver(SceneObserver object) {
		sceneObservers.remove(object);
	}

	@Override
	public void notifySceneObserversOnPrepare() {
		for (int i = 0; i < sceneObservers.size(); i++) {
			sceneObservers.get(i).onScenePrepare(IBaseScene.this);
		}
	}

	@Override
	public void notifySceneObserversOnDispose() {
		for (int i = 0; i < sceneObservers.size(); i++) {
			sceneObservers.get(i).onSceneDispose(IBaseScene.this);
		}
	}

	@Override
	public void notifySceneObserversOnTimePreElapsed() {
		for (int i = 0; i < sceneObservers.size(); i++) {
			sceneObservers.get(i).onSceneTimePreElapsed(IBaseScene.this);
		}
	}

	@Override
	public void notifySceneObserversOnTimeElapsed() {
		for (int i = 0; i < sceneObservers.size(); i++) {
			sceneObservers.get(i).onSceneTimeElapsed(IBaseScene.this);
		}
	}

	public boolean isPrepared() {
		return prepared;
	}

	public void prepare() {
		log("prepare()");
		if (!prepared && disposed) {
			disposed = false;

			onPrepare();

			notifySceneObserversOnPrepare();

			if (SettingsManager.getInstance().getDebug()
					|| isBox2dDebugForced()) {
				showDebugView();
			}

			prepared = true;
			log("fully prepared.");
		} else {
			log("Can't prepare a scene already prepared and not disposed.");
		}
	}

	protected void onPrepare() {
		Log.d(TAG, "onPrepare()");

		sceneObservers = new ArrayList<SceneObserver>();

		iTouchAreaList = new ArrayList<ITouchArea>();
		autoGeneratedBitmapTextureAtlasSet = new HashSet<BitmapTextureAtlas>();
	}

	public void addDebugButton() {
		/*
		 * DebugButton<T, TSceneType> debugButton = new DebugButton<T,
		 * TSceneType>(BaseScene.this);
		 * getChildByIndex(LAYER_TOUCH).attachChild(debugButton);
		 */
	}

	public void showDebugView() {
		eBundle.engine.registerUpdateHandler(new FPSLogger());
		if (physicsWorld != null) {
			IBaseScene.this.getChildByIndex(getDebugLayerId()).attachChild(
					new DebugRenderer(physicsWorld, eBundle.vbom));
		}
		getChildByIndex(getDebugLayerId()).attachChild(
				new DebugGrid(eBundle.vbom, 32, getSceneWidth(),
						getSceneHeight()));
	}

	public void addMuteButton() {
		addMuteButton(0, 0);
	}

	public void addMuteButton(float offsetX, float offsetY) {
		MuteButton muteButton = new MuteButton(IBaseScene.this);
		getChildByIndex(getTouchLayerId()).attachChild(muteButton);
		muteButton.setPosition(muteButton.getX() + offsetX, muteButton.getY()
				+ offsetY);
	}

	public void attachSubScene(ISubScene<T, TSceneType> subScene) {
		if (subScene == null)
			return;
		Log.d(TAG, "attachSubScene(" + subScene.getSceneType() + ")");

		if (!hasChildScene()) {
			mBundle.getSceneManager().onSubSceneAttached(subScene);
			if (subScene.pauseParentScene())
				setChildScene(subScene, false, true, true);
			else
				setChildScene(subScene);
			onPause();
		} else {
			Log.d(TAG,
					"This scene has already a sub scene, adding the new sub scene to the queue.");
			subSceneQueue.add(subScene);
		}
	}

	public void onResumeFromSubScene(ISubScene<T, TSceneType> subScene) {
		if (subSceneQueue.size() > 0) {
			Log.d(TAG, "subSceneQueue.size() > 0");
			attachSubScene(subSceneQueue.poll());
		} else {
			mBundle.getSceneManager().onSubSceneDetattached(subScene,
					IBaseScene.this);
			onResume();
		}
	}

	public void onBackKeyPressedNotInUpdateThread() {
		if (hasChildScene()) {
			eBundle.engine.runOnUpdateThread(new Runnable() {
				@Override
				public void run() {
					ISubScene<T, TSceneType> subScene = (ISubScene) getChildScene();
					subScene.onBackKeyPressed();
				}
			});
		} else {
			eBundle.engine.runOnUpdateThread(new Runnable() {
				@Override
				public void run() {
					onBackKeyPressed();
				}
			});
		}
	}

	public void onMenuKeyPressedNotInUpdateThread() {
		if (hasChildScene()) {
			eBundle.engine.runOnUpdateThread(new Runnable() {
				@Override
				public void run() {
					ISubScene<T, TSceneType> subScene = (ISubScene) getChildScene();
					subScene.onMenuKeyPressed();
				}
			});
		} else {
			eBundle.engine.runOnUpdateThread(new Runnable() {
				@Override
				public void run() {
					onMenuKeyPressed();
				}
			});
		}
	}

	public void goHome() {
		log("goHome()");
		clearChildScene();
		dispose();
		mBundle.getSceneManager().setScene(
				mBundle.getSceneManager().getHomeSceneType());
	}

	public void onExit() {
		log("onExit()");
		dispose();
		eBundle.activity.finish();
	}

	@Override
	public void dispose() {
		log("dispose()");
		if (!disposed && prepared) {
			prepared = false;

			notifySceneObserversOnDispose();

			onDispose();

			disposed = true;
			log("fully disposed.");
		} else {
			Log.w(TAG,
					"can't dispose a scene not prepared or already disposed.");
		}
	}

	protected void onDispose() {
		Log.d(TAG, "onDispose()");

		// Unregister touch areas
		while (iTouchAreaList.size() > 0) {
			ITouchArea area = iTouchAreaList.remove(0);
			unregisterTouchArea(area);
		}
		iTouchAreaList.clear();

		clearChildScene();
		clearTouchAreas();
		clearEntityModifiers();
		clearUpdateHandlers();

		subSceneQueue.clear();

		// Detach layers children
		for (int i = 0; i < getLayerCount(); i++) {
			getChildByIndex(i).detachChildren();
		}

		detachChildren();
		// super.dispose(); // when disposed can't be un-disposed

		for (BitmapTextureAtlas bitmapTextureAtlas : autoGeneratedBitmapTextureAtlasSet) {
			bitmapTextureAtlas.unload();
		}
		autoGeneratedBitmapTextureAtlasSet.clear();
	}

	public RectangleEffect getCoverEffect(RectangleEffect.Effect effect) {
		return new RectangleEffect(0, 0, getSceneWidth(), getSceneHeight(),
				effect, eBundle.vbom);
	}

	public TSceneType getChildSceneType() {
		if (hasChildScene()) {
			IBaseScene<T, TSceneType> childScene = (IBaseScene) getChildScene();
			return childScene.getSceneType();
		} else
			return null;
	}

	@Override
	public void runScript(final String basePath, final String scriptName) {
		BaseScript.runScript(basePath, scriptName, IBaseScene.this);
	}

	public int getSceneHeight() {
		return 480;
	}

	public int getSceneWidth() {
		return 800;
	}
}
